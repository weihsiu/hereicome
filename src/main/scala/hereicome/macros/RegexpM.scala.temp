package hereicome.macros

// https://www.cs.princeton.edu/courses/archive/spr09/cos333/beautiful.html
// c    matches any literal character c
// .    matches any single character
// ^    matches the beginning of the input string
// $    matches the end of the input string
// *    matches zero or more occurrences of the previous character

import scala.quoted._

object RegexpM:
  inline def matchRegexp(inline regexp: String, text: String): Boolean = ${matchRegexpImpl('regexp, 'text)}
  def matchRegexpImpl(regexp: String, text: Expr[String]) given QuoteContext: Expr[Boolean] = '{
    if regexp(0) == '^'
      then matchHere(regexp, $text, 1, 0)
      else
        var i = 0
        var r = false
        while
          if matchHere(regexp, $text, 0, i) then r = true
          !r && i + 1 != $text.length
        do i += 1
        r
  }
  inline def matchHere(inline re: String, t: String, ri: Int, ti: Int): Boolean = ${matchHereImpl('re, 't, 'ri, 'ti)}
  def matchHereImpl(re: String, t: Expr[String], ri: Expr[Int], ti: Expr[Int]) given QuoteContext: Expr[Boolean] = '{
    if $ri == $re.length then true
    else if $ri + 1 < $re.length && $re($ri + 1) == '*' then matchStar($re, $t, $re($ri), $ri + 2, $ti)
    else if $re($ri) == '$' && $ri == $re.length - 1 then $ti == $t.length
    else if $ti != $t.length && ($re($ri) == '.' || $re($ri) == $t($ti)) then matchHere($re, $t, $ri + 1, $ti + 1)
    else false
  }
  inline def matchStar(inline re: String, t: String, c: Char, ri: Int, ti: Int): Boolean = ${matchStarImpl('re, 't, 'c, 'ri, 'ti)}
  def matchStarImpl(re: Expr[String], t: Expr[String], c: Expr[Char], ri: Expr[Int], ti: Expr[Int]) given QuoteContext: Expr[Boolean] = '{
    var i = $ti
    var r = false
    while
      if matchHere($re, $t, $ri, i) then r = true
      !r && i != $t.length && (i + 1 < $t.length && $t(i + 1) == $c || $c == '.')
    do i += 1
    r
  }